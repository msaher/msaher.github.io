<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Structure and interpretation of computer programs | Saher&#39;s page</title>

      <link rel="stylesheet" href="/css/main.min.4900fe666efbd8a31ee0816c94f6bbe1c3981f909f5b9a05f0a9165d36d79b08.css" integrity="sha256-SQD&#43;Zm772KMe4IFslPa74cOYH5CfW5oF8KkWXTbXmwg=" crossorigin="anonymous">




</head>
<body>
  <header>
    <h1>Saher&#39;s page</h1>

  <nav>
    <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/writings/">Writings</a>
    </li>
    <li>
      <a aria-current="true" class="ancestor" href="/book-reviews/">Book reviews</a>
    </li>
    <li>
      <a href="/index.xml" style="color:#ff8000; font-weight: bold">RSS</a>
    </li>
    </ul>
  </nav>


  </header>
  <main>
    
  <h1>Structure and interpretation of computer programs</h1>

  
  
  <time datetime="2025-10-11T15:49:51&#43;03:00">October 11, 2025</time>

  <img style="display: block; margin: 0 auto; max-height: 300px" alt="cover" src="https://upload.wikimedia.org/wikipedia/commons/9/9d/SICP_cover.jpg"/>
<p><em>I wrote this five years after reading SICP</em></p>
<p>Often called the wizard book, SICP is considered a timeless classic that I will always hold dear to my heart for introducing me to computer science. I originally intended to become a mathematician, and I saw people online saying SICP is a good introduction for those who are mathematically minded. I was also an Emacs user back then (now a Vimmer), so I naturally had some interest in Lisps.</p>
<p>The book and its exercises were challenging at first, because I had little to no programming experience, but the wizard within me persisted. As I got better, I started having a blast reading through it and working through the exercises. My favorite exercise is 2.6, where you are asked to implement <a href="https://en.wikipedia.org/wiki/Church_encoding">church numerals</a>. To think that lambda calculus is so general and powerful that it could construct the numbers we take for granted was joyful experience for me. I still find it hilarious that exercise 2.16 tricked me into spending hours working on an <a href="https://en.wikipedia.org/wiki/Interval_arithmetic#Dependency_problem">unsolvable problem</a>. Oh and the exercises where you had to make your own computer algebra system! So many memorable problems were explored within the book.</p>
<p>SICP touches a lot of topics. Functional and imperative programming, data structures, the consequences of mutability, the expression problem, concurrency, message passing, interpreters, VMs, etc. You know a book is comprehensive when you start not knowing how to program and end with making your own language! Nearly every CS course I took in university was discussed at some point in SICP. The programming language Scheme is not important. It&rsquo;s just a vehicle for teaching those concepts. I think its comprehensive and language-agnostic approach to computer science makes it a great introduction.</p>
<p>My favorite part is how it drills into your mind the important principle of abstraction. Time and time again, it shows how unrelated problems are all solved by creating primitives, along with their means of combination to form abstraction layers that describe the system. One quote that has stuck with me:</p>
<blockquote>
<p>&hellip; the technology for coping with large-scale computer systems merges with the technology for building new computer languages, and computer science itself becomes no more (and no less) than the discipline of constructing appropriate descriptive languages.</p>
</blockquote>
<p>As great as it is, I never understood why many people made grand claims about SICP, like &ldquo;It will fundamentally change how you program&rdquo; or &ldquo;your programs will reach a higher plane of existence&rdquo;. Perhaps I do not share their sentiment because it was my first introduction to computer science and I don&rsquo;t have anything to compare it against. I did gain a lot from it, but I don&rsquo;t think there&rsquo;s anything magical in it that you couldn&rsquo;t find elsewhere.</p>
<p>The book was not perfect either. Some exercises like 1.13, felt out of place. They weren&rsquo;t hard per se, just felt irrelevant to what the authors were trying to teach. Furthermore, one can argue that starting with functional programming, with recursion, lexical scopes, and higher order functions is perhaps elegant, but less intuitive than the traditional approach of starting with imperative programming. If I were to teach a grandma computer science, then I imagine she&rsquo;ll have an easier time grasping variables, mutability, and loops over recursion and closures. Over time, as she gets accustomed to procedural systems, we can gently introduce her to functional programming, the advantages of immutability, and the elegance of higher order functions. I only sought a functional-first approach because I badly wanted to view computers as abstract systems, but most people don&rsquo;t care about that (yet).</p>
<p>Overall, even though I think the book is a bit overrated, I genuinely loved it and I think it&rsquo;s a great introduction to computer science.</p>

  


  </main>
  <footer>
    
<p style="font-weight: bold">Thoughts? Comments? Suggestions? <a href="mailto:msaher.shair@gmail.com">I'd be delighted to hear from you!</a> <span style="font-weight: normal"> :D</span></p>


  </footer>
</body>
</html>
